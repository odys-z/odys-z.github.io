<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/xmath/geom.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/xmath/geom.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as THREE from 'three'
import {vec3} from './vec';
import {XError} from '../xutils/xcommon'
import {Obj3Type} from '../component/obj3'
import {DirTubeBufferGeometry, DirTubeGeometry} from '../../packages/three/geometries/TubeGeometry'

/**
 * A collection of common math function for geometry manipulation.
 * @class xgeom
 */
export default class geom {

	/**Generate curve
	 * @param {object} cmpObj3 Obj3
	 * @param {object} paras e.g. Visual.paras
	 * paras.curve {@link CurveType}&lt;pre>
	   paras.segments: only for CurveType.randomCurve, | randomSegament generated curve segments
	   paras.range: only for CurveType.randomCurve | randomSegament, generated range, default 400
	   paras.points array of point, point = [nubmer, number, number]&lt;/pre>
	 * @return {object} {curve, points}, where geomCurve is THREE.BufferGeometry,
	 * points is the THREE.Vector3 array
	 * @member xgeom.generateCurve
	 * @function
	 */
	static generateCurve(cmpObj3, paras) {
		var dvsion = cmpObj3.box &amp;&amp; cmpObj3.box.length > 0 ? cmpObj3.box[0] : 6;
		var o = Array.isArray(paras.origin) ? paras.origin : [0, 0, 0];
		var s = paras.scale;
		s = Array.isArray(s) ? s : typeof s === 'number' ? [s, s, s] : [1, 1, 1];
		switch ( cmpObj3.geom ) {
			case Obj3Type.RandomCurve:
			case Obj3Type.RandomSects:
				var points = [];
				var r = paras.range === undefined ? 400 : paras.range;
				for ( var i = 0; i &lt; (cmpObj3.box[0] || 2); i ++ ) {
				// for ( var i = 0; i &lt; 2; i ++ ) {
					var x = Math.random() * r - r / 2;
					var y = Math.random() * r - r / 2;
					var z = Math.random() * r - r / 2;
					points.push( new THREE.Vector3( x, y, z ) );
					// TODO add other attributes like colour here
				}
				// var line,
				var geomCurve, line;
				if (cmpObj3.geom === Obj3Type.RandomCurve) {
				 	line = new THREE.CatmullRomCurve3( points );
					var samples = line.getPoints( points.length * dvsion )
					geomCurve = new THREE.BufferGeometry().setFromPoints( samples );
				}
				else {
					geomCurve = new THREE.BufferGeometry().setFromPoints( points );
					// line = new THREE.LineSegments(geomCurve);
				}
				return {geomCurve, points, curve: line};
			case Obj3Type.PointSects:
				// FIXME API needing to be redesigned
				// FIXME There should be a regularized way to express geometry paramters
				// E.g. paras.sects can be the same for both GeomCurve and DynaSects
				var points = [];
				for (var segx = 0; segx &lt; paras.points.length; segx ++) {
					var xyz = paras.points[segx];
					points.push( new THREE.Vector3( (xyz[0] + o[0]) * s[0],
													(xyz[1] + o[1]) * s[1],
													(xyz[2] + o[2]) * s[2] ) );
				}
				var geomCurve = new THREE.BufferGeometry().setFromPoints( points );
				return {geomCurve, points};
			case Obj3Type.PointGrid:
			case Obj3Type.PointCurve:
				var points = [];
				for (var segx = 0; segx &lt; paras.points.length; segx++) {
					var xyz = paras.points[segx];
					points.push( new THREE.Vector3( (xyz[0] + o[0]) * s[0],
								(xyz[1] + o[1]) * s[1], (xyz[2] + o[2]) * s[2] ) );
				}
			 	var line = new THREE.CatmullRomCurve3( points );
				var samples = line.getPoints( points.length * dvsion );	// not for svg path
				geomCurve = new THREE.BufferGeometry().setFromPoints( samples );
				return {geomCurve, points, curve: line};
			case Obj3Type.SvgPath:
			default:
				throw new XError('Unsupported curve: ', cmpObj3.geom, cmpObj3);
		}
	}

	/**Create a {@link DirTubeBufferGeometry} for rendering and tweening.
	 *
	 * The vertices should include attributes of 'tan', and uniform 'wpos', the
	 * world pos can by tweend as {@link XComponent.AnimType}.U_PATH_MORPH.
	 *
	 * @return {object} {tube, path}, where tube is THREE.BufferGeometry,
	 * @member xgeom.generateDirTube
	 */
	static generateDirTube(obj3, paras) {
		var {geomCurve, points, curve} = geom.generateCurve(obj3, paras);

		if (!curve)
			throw new XError('Only curve can be used for generating tube mesh. Entity ',
							obj3.entitye.id);

		// var tube = new THREE.TubeBufferGeometry( curve, paras.tubularSegments || 20,
		// 				paras.radius || 2, paras.radialSegments || 6, paras.closed || false );
		var tube = new DirTubeBufferGeometry( curve, paras.tubularSegments || 20,
						paras.radius || 2, paras.radialSegments || 6, paras.closed || false );

		return {tube, path: curve};
	}

	/**Generate curve
	 * @param {object} cmpObj3 Obj3
	 * @param {object} paras e.g. Visual.paras
	   paras.points: 2d array of points, segment = [[x, y, z], [x, y, z]]
	   paras.scale: scale of points, useful when mappig grid index to chart world&lt;/pre>
	 * @return {object} {curve, points}, where geomCurve is THREE.BufferGeometry,
	 * points is the THREE.Vector3 array
	 * @member xgeom.generateDynaSects
	 * @function
	 */
	static generateDynaSects(cmpObj3, paras) {
		switch (cmpObj3.geom) {
			case Obj3Type.RandomSect:
				throw new XError('geom.generateLines: TODO RandomSect');
				break;
			case Obj3Type.PointSects:
				var sects = [];
				var threeVec3s = [];
				var o = Array.isArray(paras.origin) ? paras.origin : [0, 0, 0];
				var s = paras.scale === undefined ? 1 : paras.scale;
				var sx, sy, sz;
				if (Array.isArray(s)) {
					sx = s[0]; sy = s[1]; sz = s[2];
				}
				else if (typeof s === 'number') {
					sx = sy = sz = s;
				}
				else sx = sy = sz = 1;

				for ( var segx = 0; segx &lt; paras.sects.length; segx++ ) {
					var xyz = paras.sects[segx][0];
					var p1 = new THREE.Vector3( (xyz[0] + o[0]) * sx,
												(xyz[1] + o[1]) * sy,
												(xyz[2] + o[2]) * sz );
					xyz = paras.sects[segx][1];
					var p2 = new THREE.Vector3( (xyz[0] + o[0]) * sx,
												(xyz[1] + o[1]) * sy,
												(xyz[2] + o[2]) * sz );
					var geom = new THREE.BufferGeometry().setFromPoints( [p1, p2] );
					threeVec3s.push( [p1, p2] );
					sects.push( geom );
				}
				return {geoms: sects, points: threeVec3s};
			default:
				throw new XError('geom.generateLines: Unsupported line geometry: ',
								cmpObj3.geom, cmpObj3);
		}
	}

	static generateWayxz(paths, y0, origin, style, angleEpsilon) {
		const epsilon = angleEpsilon || 0.5;
		const halfW = style ? style.halfWidth || 10 : 10;
		const geoScale = style ? style.geoScale || 1 : 1;
		const o = origin || [0, 0, 0];
		y0 = y0 || 0;
		var l0 = [0, 0, 0], l1 = [0, 0, 0], l2 = [0, 0, 0];
		var r2 = [0, 0, 0], r1 = [0, 0, 0], r0 = [0, 0, 0];
		var l1_ = [0, 0, 0], r1_ = [0, 0, 0];
		var dir = [0, 0, 0], dir1 = [0, 0, 0];
		var plen = 0, plen_done = 0;
		for (var path of paths)
			plen += path.geometry.coordinates.length;

		var waypoints = new Float32Array(2 * plen * 3); // double side
		var uvs = new Float32Array(2 * plen * 2);
		var normals = new Float32Array(2 * plen * 3);;
		var dirs = new Float32Array(2 * plen * 3);
		var index = [];

		for (var geoFeature of paths) {
			var path = geoFeature.geometry.coordinates;
			var pleni = path.length;
			for (var pi = 0; pi &lt; pleni; pi++) {
				var u = pleni > 1 ? pi / (pleni - 1) : pi; // reset u for each segment
				if (pi > 0)
					dir = pathDir(path, pi, dir);
				else
					dir = pathDir(path, pi+1, dir);

				// var l_i0, l_i1, l_i2, r_i0, r_i1, r_i2; // way points indices
				l_i0 = 2 * plen - 1 - (pi + plen_done);
				r_i2 = pi + plen_done;
				var l_i0, l_i1, r_i1, r_i2; // way points indices
				if (pi > 0) {
					l_i1 = l_i0 + 1;
					r_i1 = r_i2 - 1;
				}

				vec3.scaleTo(1, dir);
				dirs.set(dir, pi * 3);

				// current path point
				var p0 = [(path[pi][0] - o[0]) * geoScale,
						   y0 || 0,       // in xz plane of geo point
						  (path[pi][1] - o[1]) * geoScale]; // +z = south (3857 smaller y)
				// console.log(p0[0], p0[2]);

				vec3.copyArr(l2, l1);
				vec3.copyArr(l1, l0);
				l0 = geom.xzExpandWaypoint(p0, dir, halfW, y0, l0, true);

				vec3.copyArr(r0, r1);
				vec3.copyArr(r1, r2);
				r2 = geom.xzExpandWaypoint(p0, dir, halfW, y0, r2);
				// console.log(r2[0], r2[2]);

				if (pi > 1) {
					// previous path point, used for finding the 2nd segment
					var p_1 = [(path[pi-1][0] - o[0]) * geoScale,
							   y0 || 0,
							   // (o[1] - path[pi-1][1]) * geoScale];    // +z = south (3857 smaller y)
							   (path[pi-1][1] - o[1]) * geoScale];    // +z = south (3857 smaller y)
					pathDir(path, pi-1, dir1);
					if (geom.xzAngle( dir1, dir ) &lt; epsilon) {
						// intersection will result in wrong position - precision isssue?
						debugger
					}
					else {
						var l1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[2]], dir, halfW, y0, l1_, true);
						var r1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[2]], dir, halfW, y0, r1_);

						// plen = 12,
						// i = 0,         i = 1;          i = 2;        i = 3
						// r0: 0, l2: 21; r1: 3, l1: 18; r2: 6, l2: 15; r3: 9, l3: 12
						checkSide(l0, l1_, l1, l2, l1_);  // note index in reversed order
						// waypoints.set(l1_, l_i1 * 3);
						setWaypoints(l1_, l_i1);

						checkSide(r0, r1, r1_, r2, r1_);
						// waypoints.set(r1_, r_i1 * 3);
						setWaypoints(r1_, r_i1);
					}
				}

				// waypoints.set(l0, l_i0 * 3);
				setWaypoints(l0, l_i0);
				uvs.set([u, 0], l_i0 * 2);
				normals.set([0, 1, 0], l_i0 * 3);
				dirs.set(dir, l_i0 * 3);

				// waypoints.set(r2, r_i2 * 3);
				setWaypoints(r2, r_i2);
				uvs.set([u, 1], r_i2 * 2);
				normals.set([0, 1, 0], r_i2 * 3);
				dirs.set(dir, r_i2 * 3);

				if (pi > 0) {
				    // var a = l_i1, b = r_i1, c = r_i2, d = l_i0;
					// 3857 y = three.js -z
				    var a = r_i1, b = l_i1, c = l_i0, d = r_i2;
				    index.push(a, b, d);
				    index.push(b, c, d);
				}
			}
			plen_done += pleni;
			// TODO add round cap?
		}

		var pathGeometry = new THREE.BufferGeometry();
		pathGeometry.setAttribute("position", new THREE.BufferAttribute(waypoints, 3));
		pathGeometry.setAttribute("geoLoc", new THREE.Float32BufferAttribute(path, 3));
		pathGeometry.setAttribute("geoDir", new THREE.BufferAttribute(dirs, 3));

		pathGeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		pathGeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		pathGeometry.setIndex(index);

		return pathGeometry;

		function pathDir(geopath, ix, buff, y0) {
			return vec3.subArr(
				[geopath[ix][0], y0 || 0, geopath[ix][1]],
				[geopath[ix-1][0], y0 || 0, geopath[ix-1][1]], buff);
		}

		function checkSide(p0, p1, p2, p3, buf) {
			var reslt = geom.checkLineIntersection(
				p0[0], p0[2], p1[0], p1[2],
				p2[0], p2[2], p3[0], p3[2] );

			buf[0] = reslt.x;
			buf[2] = reslt.y;
			return buf;
		}

		function setWaypoints(p, ix) {
			// 3857 y = three.js -z, reverse p[2]
			waypoints.set([p[0], p[1], -p[2]], ix * 3);
		}
	}

	/** return |atan(vec0[2], vec0[0]) - atan(vec1[2], vec[0])|
	 * @param {array} vec0 [x, y, z]
	 * @param {array} vec1 [x, y, z]
	 * @member xgeom.xzAngle
	 */
	static xzAngle(vec0, vec1) {
		var a0 = Math.atan2(vec0[2], vec0[0]);
		return Math.abs(a0 - Math.atan2(vec1[2], vec1[0]));
	}

	static xzExpandWaypoint(p, dir, w, y0, buf, isLeft) {
		var off = [0, 0, 0];
		vec3.crossArr(dir, [0, isLeft ? -1 : 1, 0], off);
		vec3.scaleTo(w, off);
		vec3.addArr(p, off, buf);
		if (y0 !== undefined)
			buf[1] = y0;
		return buf;
	}

	/**Find 2d line intersection&lt;br>
	 * Line1: [(x1, y1), (x2, y2)]&lt;br>
	 * Line2: [(x3, y3), (x4, y4)]&lt;br>
	 * Reference:
	 * &lt;a href='http://jsfiddle.net/justin_c_rounds/Gd2S2/'>
	   justin_c_rounds's Calculating the intersection of two lines&lt;/a>
	 * &lt;a href='https://mathjs.org/docs/reference/functions/intersect.html'>
	 * Math.js 3D version&lt;/a>
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x4
	 * @param {number} y4
	 * @return {object} {x: number | null, y: number | null, onL1: bool, onL2: bool}
	 * @member xgeom.generateDynaSects
	 * @function
	 */
 	static checkLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
	    var denominator, a, b, numerator1, numerator2, result = {
			x: x2,
			y: y2,
			xy: [x2, y2],
			onLine1: true,
			onLIne2: true
	    };
	    denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
	    if (denominator == 0) {
	        return result;
	    }
	    a = y1 - y3;
	    b = x1 - x3;
	    numerator1 = ((x4 - x3) * a) - ((y4 - y3) * b);
	    numerator2 = ((x2 - x1) * a) - ((y2 - y1) * b);
	    a = numerator1 / denominator;
	    b = numerator2 / denominator;

	    // if we cast these lines infinitely in both directions, they intersect here:
	    result.x = x1 + (a * (x2 - x1));
	    result.y = y1 + (a * (y2 - y1));
		result.xy = [x1 + (a * (x2 - x1)), y1 + (a * (y2 - y1))];

		/*
	    // it is worth noting that this should be the same as:
	       x = x3 + (b * (x4 - x3));
	       y = x3 + (b * (y4 - y3));
	    */
	    // if line1 is a segment and line2 is infinite, they intersect if:
	    if (a > 0 &amp;&amp; a &lt; 1) {
	        result.onLine1 = true;
	    }
	    // if line2 is a segment and line1 is infinite, they intersect if:
	    if (b > 0 &amp;&amp; b &lt; 1) {
	        result.onLine2 = true;
	    }
	    // if line1 and line2 are segments, they intersect if both of the above are true
	    return result;
	}

	// static generateWayxz(paths, y0, origin, style, epsilon) {
	// 	epsilon = epsilon || 0.1;
	// 	const halfW = style ? style.halfWidth || 10 : 10;
	// 	const geoScale = style ? style.geoScale || 1 : 1;
	// 	const o = origin || [0, 0, 0];
	// 	y0 = y0 || 0;
	// 	var l0 = [0, 0, 0];
	// 	var l1 = [0, 0, 0];
	// 	var l2 = [0, 0, 0];
	// 	var r2 = [0, 0, 0];
	// 	var r1 = [0, 0, 0];
	// 	var r0 = [0, 0, 0];
	// 	var l1_ = [0, 0, 0]; //
	// 	var r1_ = [0, 0, 0]; //
	// 	var dir = [0, 0, 0];
	// 	var plen = 0;
	// 	var plen_done = 0;
	// 	for (var path of paths)
	// 		plen += path.geometry.coordinates.length;
	//
	// 	var waypoints = new Float32Array(2 * plen * 3); // double side
	// 	var uvs = new Float32Array(2 * plen * 2);
	// 	var normals = new Float32Array(2 * plen * 3);;
	// 	var dirs = new Float32Array(2 * plen * 3);
	// 	var index = [];
	//
	// 	for (var geoFeature of paths) {
	// 		var path = geoFeature.geometry.coordinates;
	// 		var pleni = path.length;
	// 		var k0 = 0, k1 = 0;
	// 		for (var pi = 0; pi &lt; pleni; pi++) {
	// 			var u = pleni > 1 ? pi / (pleni - 1) : pi; // reset u for each segment
	// 			if (pi > 0)
	// 				dir = pathDir(path, pi, dir);
	// 			else
	// 				dir = pathDir(path, pi+1, dir);
	//
	// 			// var l_i0, l_i1, l_i2, r_i0, r_i1, r_i2; // way points indices
	// 			l_i0 = 2 * plen - 1 - (pi + plen_done);
	// 			r_i2 = pi + plen_done;
	// 			var l_i0, l_i1, r_i1, r_i2; // way points indices
	// 			if (pi > 0) {
	// 				l_i1 = l_i0 + 1;
	// 				r_i1 = r_i2 - 1;
	// 			}
	//
	// 			vec3.scaleTo(1, dir);
	// 			dirs.set(dir, pi * 3);
	//
	// 			// var p0 = [path[pi][0] - o[0], 0, path[pi][1] - o[1]];    // in xz plane of geo point
	// 			var p0 = [(path[pi][0] - o[0]) * geoScale,
	// 						y0 || 0,
	// 					  (path[pi][1] - o[1]) * geoScale];    // in xz plane of geo point
	// 			console.log(p0[0], p0[2]);
	//
	// 			vec3.copyArr(l2, l1);
	// 			vec3.copyArr(l1, l0);
	// 			l0 = geom.xzExpandWaypoint(p0, dir, halfW, y0, l0, true);
	//
	// 			vec3.copyArr(r0, r1);
	// 			vec3.copyArr(r1, r2);
	// 			r2 = geom.xzExpandWaypoint(p0, dir, halfW, y0, r2);
	//
	// 			if (pi > 1) {
	// 				// previous path point, used for finding the 2nd segment
	// 				// var p_1 = path[pi - 1];
	// 				var p_1 = [(path[pi-1][0] - o[0]) * geoScale,
	// 							y0 || 0,
	// 						   (path[pi-1][1] - o[1]) * geoScale];    // in xz plane of geo point
	// 				k0 = k1;
	// 				var x2_x1 = path[pi][0] - path[pi-1][0];
	// 				k1 = Math.abs(x2_x1) &lt; epsilon ? Infinity : (path[pi][1] - path[pi-1][1]) / x2_x1;
	// 				if (k0 === Infinity &amp;&amp; k1 === Infinity
	// 					|| Math.abs(k1 - k0) &lt; epsilon) {
	// 					// almost parallel, keep l1 &amp; r1
	// 					debugger
	// 				}
	// 				else {
	// 					var l1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, l1_, true);
	// 					var r1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, r1_);
	//
	// 					// plen = 12,
	// 					// i = 0,         i = 1;          i = 2;        i = 3
	// 					// r0: 0, l2: 21; r1: 3, l1: 18; r2: 6, l2: 15; r3: 9, l3: 12
	// 					// l_i2 = l_i0 + 2;
	// 					// r_i0 = r_i2 - 2;
	// 					checkSide(l0, l1_, l1, l2, l1_);  // note index in reversed order
	// 					waypoints.set(l1_, l_i1 * 3);
	//
	// 					checkSide(r0, r1, r1_, r2, r1_);
	// 					waypoints.set(r1_, r_i1 * 3);
	// 				}
	// 			}
	//
	// 			waypoints.set(l0, l_i0 * 3);
	// 			uvs.set([u, 0], l_i0 * 2);
	// 			normals.set([0, 1, 0], l_i0 * 3);
	// 			dirs.set(dir, l_i0 * 3);
	//
	// 			waypoints.set(r2, r_i2 * 3);
	// 			uvs.set([u, 1], r_i2 * 2);
	// 			normals.set([0, 1, 0], r_i2 * 3);
	// 			dirs.set(dir, r_i2 * 3);
	//
	// 			if (pi > 0) {
	// 			    var a = l_i1, b = r_i1, c = r_i2, d = l_i0;
	// 			    index.push(a, b, d);
	// 			    index.push(b, c, d);
	// 			}
	// 		}
	// 		plen_done += pleni;
	// 		// TODO add round cap?
	// 	}
	//
	// 	var pathGeometry = new THREE.BufferGeometry();
	// 	pathGeometry.setAttribute("position", new THREE.BufferAttribute(waypoints, 3));
	// 	pathGeometry.setAttribute("geoLoc", new THREE.Float32BufferAttribute(path, 3));
	// 	pathGeometry.setAttribute("geoDir", new THREE.BufferAttribute(dirs, 3));
	//
	// 	pathGeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	// 	pathGeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	//
	// 	pathGeometry.setIndex(index);
	//
	// 	return pathGeometry;
	//
	// 	function pathDir(geopath, ix, buff, y0) {
	// 		return vec3.subArr(
	// 			[geopath[ix][0], y0 || 0, geopath[ix][1]],
	// 			[geopath[ix-1][0], y0 || 0, geopath[ix-1][1]], buff);
	// 	}
	//
	// 	function checkSide(p0, p1, p2, p3, buf) {
	// 		var reslt = geom.checkLineIntersection(
	// 			p0[0], p0[2], p1[0], p1[2],
	// 			p2[0], p2[2], p3[0], p3[2] );
	//
	// 		buf[0] = reslt.x;
	// 		buf[2] = reslt.y;
	// 		return buf;
	// 	}
	// }

	/*
	static generateWayxz(paths, y0, origin, style) {
		// for face, use plane XZ (y = 0)
		// for path, use line segments
		const halfW = style ? style.halfWidth || 10 : 10;
		const geoScale = style ? style.geoScale || 1 : 1;
		const o = origin || [0, 0, 0];
		y0 = y0 || 0;
		var l0 = [0, 0, 0];
		var r2 = [0, 0, 0];
		var l1_ = [0, 0, 0]; //
		var r1_ = [0, 0, 0]; //
		var dir = [0, 0, 0];
		var plen = 0;
		var plen_done = 0;
		for (var path of paths)
			plen += path.geometry.coordinates.length;

		var waypoints = new Float32Array(2 * plen * 3); // double side
		var uvs = new Float32Array(2 * plen * 2);
		var normals = new Float32Array(2 * plen * 3);;
		var dirs = new Float32Array(2 * plen * 3);
		var index = [];

		for (var geoFeature of paths) {
			var path = geoFeature.geometry.coordinates;
			var pleni = path.length;
			for (var pi = 0; pi &lt; pleni; pi++) {
				var u = pleni > 1 ? pi / (pleni - 1) : pi; // reset u for each segment
				if (pi > 0)
					dir = pathDir(path, pi, dir);
				else
					dir = pathDir(path, pi+1, dir);

				var l_i0, l_i1, l_i2, r_i0, r_i1, r_i2; // way points indices
				l_i0 = 2 * plen - 1 - (pi + plen_done);
				r_i2 = pi + plen_done;
				if (pi > 0) {
					l_i1 = l_i0 + 1;
					r_i1 = r_i2 - 1;
				}

				vec3.scaleTo(1, dir);
				dirs.set(dir, pi * 3);

				// var p0 = [path[pi][0] - o[0], 0, path[pi][1] - o[1]];    // in xz plane of geo point
				var p0 = [(path[pi][0] - o[0]) * geoScale,
							y0 || 0,
						  (path[pi][1] - o[1]) * geoScale];    // in xz plane of geo point
				console.log(p0[0], p0[2]);

				l0 = geom.xzExpandWaypoint(p0, dir, halfW, y0, l0, true);

				r2 = geom.xzExpandWaypoint(p0, dir, halfW, y0, r2);

				if (pi > 1) {
					// previous path point, used for finding the 2nd segment
					// var p_1 = path[pi - 1];
					var p_1 = [(path[pi-1][0] - o[0]) * geoScale,
								y0 || 0,
							   (path[pi-1][1] - o[1]) * geoScale];    // in xz plane of geo point
					var l1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, l1_, true);
					var r1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, r1_);

					// plen = 12,
					// i = 0,         i = 1;          i = 2;        i = 3
					// r0: 0, l2: 21; r1: 3, l1: 18; r2: 6, l2: 15; r3: 9, l3: 12
					l_i2 = l_i0 + 2;
					r_i0 = r_i2 - 2;
					var l1 =  [ waypoints[l_i1 * 3],
								waypoints[l_i1 * 3 + 1],
								waypoints[l_i1 * 3 + 2] ];
					var l2 =  [ waypoints[l_i2 * 3],
								waypoints[l_i2 * 3 + 1],
								waypoints[l_i2 * 3 + 2] ];
					l1 = checkSide(l0, l1_, l1, l2);  // note index in reversed order
					waypoints.set(l1, l_i1 * 3);

					var r1 =  [ waypoints[r_i1 * 3],
								waypoints[r_i1 * 3 + 1],
								waypoints[r_i1 * 3 + 2] ];
					var r0 =  [ waypoints[r_i0 * 3],
								waypoints[r_i0 * 3 + 1],
								waypoints[r_i0 * 3 + 2] ];
					r1 = checkSide(r0, r1, r1_, r2);
					waypoints.set(r1, r_i1 * 3);
				}

				waypoints.set(l0, l_i0 * 3);
				uvs.set([u, 0], l_i0 * 2);
				normals.set([0, 1, 0], l_i0 * 3);
				dirs.set(dir, l_i0 * 3);

				waypoints.set(r2, r_i2 * 3);
				uvs.set([u, 1], r_i2 * 2);
				normals.set([0, 1, 0], r_i2 * 3);
				dirs.set(dir, r_i2 * 3);

				if (pi > 0) {
				    var a = l_i1, b = r_i1, c = r_i2, d = l_i0;
				    index.push(a, b, d);
				    index.push(b, c, d);
				}
			}
			plen_done += pleni;
			// TODO add round cap?
		}

		var pathGeometry = new THREE.BufferGeometry();
		pathGeometry.setAttribute("position", new THREE.BufferAttribute(waypoints, 3));
		pathGeometry.setAttribute("geoLoc", new THREE.Float32BufferAttribute(path, 3));
		pathGeometry.setAttribute("geoDir", new THREE.BufferAttribute(dirs, 3));

		pathGeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		pathGeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		pathGeometry.setIndex(index);

		return pathGeometry;

		function pathDir(geopath, ix, buff, y0) {
			// vec3.subArr(path[ix + 1], path[ix], buff)
			return vec3.subArr(
				[geopath[ix][0], y0 || 0, geopath[ix][1]],
				[geopath[ix-1][0], y0 || 0, geopath[ix-1][1]], buff);
		}

		function checkSide(p0, p1, p2, p3) {
			var reslt = geom.checkLineIntersection(
				p0[0], p0[2], p1[0], p1[2],
				p2[0], p2[2], p3[0], p3[2] );

			p2[0] = reslt.x;
			p2[2] = reslt.y;
			return p2;
		}
	}
		*/

	/**Generate face of polygon from geo-path.
	 * A discussion at stackoverflow:
	 * https://stackoverflow.com/questions/15247711/convert-an-svg-path-to-polygons-for-use-within-javascript-clipper
	 * https://gis.stackexchange.com/questions/7159/pure-javascript-library-for-geometry-operations
	 *
	 * renferences
	 * paper.js (path geom) http://paperjs.org/features/#paths-x26-segments
	 * mapshaper https://mapshaper.org/
	 * polygon-tool (2d intersection, ect.)
	 *     home: https://floorplanner.github.io/polygon-tools/
	 *     jsfiddle: https://jsfiddle.net/timknip/2tjkuvvj/
	 * @param {array} path 2d array, each element is a vec2 array (geojson polygon point)
	 * @param {number} [y0=0] the xz plane's y
	 * @param {object} style {halfWidth: number}
	static generateWayxz(path, y0, style) {
		// for face, use plane XZ (y = 0)
		// for path, use line segments
		const halfW = style ? style.halfWidth || 10 : 10;
		y0 = y0 || 0;
		var l0 = [0, 0, 0];
		var r2 = [0, 0, 0];
		var l1_ = [0, 0, 0]; //
		var r1_ = [0, 0, 0]; //
		var dir = [0, 0, 0];
		var plen = path.length;

		var waypoints = new Float32Array(2 * plen * 3); // double side
		var uvs = new Float32Array(2 * plen * 2);
		var normals = new Float32Array(2 * plen * 3);;
		var dirs = new Float32Array(2 * plen * 3);
		var index = [];

		for (var pi = 0; pi &lt; plen; pi++) {
			if (pi > 0)
				dir = pathDir(path, pi, dir);
			else
				dir = pathDir(path, pi+1, dir);

			var l_i0, l_i1, l_i2, r_i0, r_i1, r_i2; // way points indices
			l_i0 = 2 * plen - 1 - pi;
			r_i2 = pi;
			if (pi > 0) {
				l_i1 = l_i0 + 1;
				r_i1 = r_i2 - 1;
			}
			var u = pi / (plen - 1);

			vec3.scaleTo(1, dir);
			dirs.set(dir, pi * 3);

			var p0 = [path[pi][0], 0, path[pi][1]];    // in xz plane of geo point

			l0 = geom.xzExpandWaypoint(p0, dir, halfW, y0, l0, true);

			r2 = geom.xzExpandWaypoint(p0, dir, halfW, y0, r2);

			if (pi > 1) {
				// previous path point, used for finding the 2nd segment
				var p_1 = path[pi - 1];
				var l1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, l1_, true);
				var r1_ = geom.xzExpandWaypoint([p_1[0], y0, p_1[1]], dir, halfW, y0, r1_);

				// plen = 12,
				// i = 0,         i = 1;          i = 2;        i = 3
				// r0: 0, l2: 21; r1: 3, l1: 18; r2: 6, l2: 15; r3: 9, l3: 12
				l_i2 = l_i0 + 2;
				r_i0 = r_i2 - 2;
				var l1 =  [ waypoints[l_i1 * 3],
							waypoints[l_i1 * 3 + 1],
							waypoints[l_i1 * 3 + 2] ];
				var l2 =  [ waypoints[l_i2 * 3],
							waypoints[l_i2 * 3 + 1],
							waypoints[l_i2 * 3 + 2] ];
				l1 = checkSide(l0, l1_, l1, l2);  // note index in reversed order
				waypoints.set(l1, l_i1 * 3);

				var r1 =  [ waypoints[r_i1 * 3],
							waypoints[r_i1 * 3 + 1],
							waypoints[r_i1 * 3 + 2] ];
				var r0 =  [ waypoints[r_i0 * 3],
							waypoints[r_i0 * 3 + 1],
							waypoints[r_i0 * 3 + 2] ];
				r1 = checkSide(r0, r1, r1_, r2);
				waypoints.set(r1, r_i1 * 3);
			}

			waypoints.set(l0, l_i0 * 3);
			uvs.set([u, 0], l_i0 * 2);
			normals.set([0, 1, 0], l_i0 * 3);
			dirs.set(dir, l_i0 * 3);

			waypoints.set(r2, r_i2 * 3);
			uvs.set([u, 1], r_i2 * 2);
			normals.set([0, 1, 0], r_i2 * 3);
			dirs.set(dir, r_i2 * 3);

			if (pi > 0) {
			    var a = l_i1, b = r_i1, c = r_i2, d = l_i0;
			    index.push(a, b, d);
			    index.push(b, c, d);
			}
		}
		// TODO add round cap?

		var pathGeometry = new THREE.BufferGeometry();
		pathGeometry.setAttribute("position", new THREE.BufferAttribute(waypoints, 3));
		pathGeometry.setAttribute("geoLoc", new THREE.Float32BufferAttribute(path, 3));
		pathGeometry.setAttribute("geoDir", new THREE.BufferAttribute(dirs, 3));

		pathGeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		pathGeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		pathGeometry.setIndex(index);

		return pathGeometry;

		function pathDir(geopath, ix, buff, y0) {
			// vec3.subArr(path[ix + 1], path[ix], buff)
			return vec3.subArr(
				[geopath[ix][0], y0 || 0, geopath[ix][1]],
				[geopath[ix-1][0], y0 || 0, geopath[ix-1][1]], buff);
		}

		function checkSide(p0, p1, p2, p3) {
			var reslt = geom.checkLineIntersection(
				p0[0], p0[2], p1[0], p1[2],
				p2[0], p2[2], p3[0], p3[2] );

			p1[0] = reslt.x;
			p1[2] = reslt.y;
			return p1;
		}
	}
	 */

	/**Get point alone path, at weight t, and set result point in buffer.
	 *
	 * Stolen from SplineCurve.prototype.getPoint
	 *
	 * https://github.com/mrdoob/three.js/blob/master/src/extras/curves/SplineCurve.js
	 *
	 * @param {THREE.Vector3} pointBuffer
	 * @param {array&lt;THREE.Vector3>} path point array of THREE.Vector3
	 * @param {number} t weight, range 0 - 1
	 * @return {THREE.Vector3} point
	 * @member xgeom.getPointAt
	 * @function
	 */
	static getPointAt(pointBuffer, path, t) {
		var point = pointBuffer || new Vector3();

		var points = path; //.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		if (intPoint &lt; 0) {
			console.warn('Point index out of range. P: ',
				intPoint, 'buffer: ', pointBuffer, 't: ', t, 'path: ', path);
			intPoint = 0;
		}
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			geom.catmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			geom.catmullRom( weight, p0.y, p1.y, p2.y, p3.y ),
			geom.catmullRom( weight, p0.z, p1.z, p2.z, p3.z )
		);

		return point;
	}

	/**Doc:
	 * &lt;a href='https://threejs.org/docs/#api/en/extras/core/Curve.getPoint'>
	 * Returns a vector for a given position on the curve&lt;/a>.
	 *
	 * Stolen from:
	 * https://github.com/mrdoob/three.js/blob/b11f897812a8a48bcd81e9bd46785d07939ec59e/src/extras/core/Interpolations.js#L8
	 *
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 * @member xgeom.catmullRom
	 * @function
	 */
	static catmullRom( t, p0, p1, p2, p3 ) {
		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	}
}

// https://discourse.threejs.org/t/simple-rectangular-geometry-extrusion-anyone/743/14
function ProfiledContourGeometry(profileShape, contour, contourClosed) {

	contourClosed = contourClosed !== undefined ? contourClosed : true;

	let profileGeometry = new THREE.ShapeBufferGeometry(profileShape);
	profileGeometry.rotateX(Math.PI * .5);
	let profile = profileGeometry.attributes.position;

	let profilePoints = new Float32Array(profile.count * contour.length * 3);

	// odys: generate profiles alone contour
	for (let i = 0; i &lt; contour.length; i++) {
	  let v1 = new THREE.Vector2().subVectors(contour[i - 1 &lt; 0 ? contour.length - 1 : i - 1], contour[i]);
	  let v2 = new THREE.Vector2().subVectors(contour[i + 1 == contour.length ? 0 : i + 1], contour[i]);
	  let angle = v2.angle() - v1.angle();
	  let halfAngle = angle * .5;

	  let hA = halfAngle;
	  let tA = v2.angle() + Math.PI * .5;
	  if (!contourClosed){
	  	if (i == 0 || i == contour.length - 1) {hA = Math.PI * .5;}
	    if (i == contour.length - 1) {tA = v1.angle() - Math.PI * .5;}
	  }

	  let shift = Math.tan(hA - Math.PI * .5);
	  let shiftMatrix = new THREE.Matrix4().set(
	        1,  0, 0, 0,
	    -shift, 1, 0, 0,
	        0,  0, 1, 0,
	        0,  0, 0, 1
	  );


	  let tempAngle = tA;
	  let rotationMatrix = new THREE.Matrix4().set(
	    Math.cos(tempAngle), -Math.sin(tempAngle), 0, 0,
	    Math.sin(tempAngle), Math.cos(tempAngle), 0, 0,
	    0, 0, 1, 0,
	    0, 0, 0, 1
	  );

	  let translationMatrix = new THREE.Matrix4().set(
	    1, 0, 0, contour[i].x,
	    0, 1, 0, contour[i].y,
	    0, 0, 1, 0,
	    0, 0, 0, 1,
	  );

	  let cloneProfile = profile.clone();
	  shiftMatrix.applyToBufferAttribute(cloneProfile);
	  rotationMatrix.applyToBufferAttribute(cloneProfile);
	  translationMatrix.applyToBufferAttribute(cloneProfile);

	  profilePoints.set(cloneProfile.array, cloneProfile.count * i * 3);
	}

	let fullProfileGeometry = new THREE.BufferGeometry();
	fullProfileGeometry.addAttribute("position", new THREE.BufferAttribute(profilePoints, 3));
	let index = [];

	let lastCorner = contourClosed == false ? contour.length - 1: contour.length;
	for (let i = 0; i &lt; lastCorner; i++) {
	  for (let j = 0; j &lt; profile.count; j++) {
	    let currCorner = i;
	    let nextCorner = i + 1 == contour.length ? 0 : i + 1;
	    let currPoint = j;
	    let nextPoint = j + 1 == profile.count ? 0 : j + 1;

	    let a = nextPoint + profile.count * currCorner;
	    let b = currPoint + profile.count * currCorner;
	    let c = currPoint + profile.count * nextCorner;
	    let d = nextPoint + profile.count * nextCorner;


	    index.push(a, b, d);
	    index.push(b, c, d);
	  }
	}

	fullProfileGeometry.setIndex(index);
	fullProfileGeometry.computeVertexNormals();

	return fullProfileGeometry;
}

// source of three.module.js/Curve line 36499
function computeFrenetFrames( segments, closed ) {
	// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

	var normal = new Vector3();

	var tangents = [];
	var normals = [];
	var binormals = [];

	var vec = new Vector3();
	var mat = new Matrix4();

	var i, u, theta;

	// compute the tangent vectors for each segment on the curve

	for ( i = 0; i &lt;= segments; i ++ ) {

		u = i / segments;

		tangents[ i ] = this.getTangentAt( u );
		tangents[ i ].normalize();

	}

	// select an initial normal vector perpendicular to the first tangent vector,
	// and in the direction of the minimum tangent xyz component

	normals[ 0 ] = new Vector3();
	binormals[ 0 ] = new Vector3();
	var min = Number.MAX_VALUE;
	var tx = Math.abs( tangents[ 0 ].x );
	var ty = Math.abs( tangents[ 0 ].y );
	var tz = Math.abs( tangents[ 0 ].z );

	if ( tx &lt;= min ) {

		min = tx;
		normal.set( 1, 0, 0 );

	}

	if ( ty &lt;= min ) {

		min = ty;
		normal.set( 0, 1, 0 );

	}

	if ( tz &lt;= min ) {

		normal.set( 0, 0, 1 );

	}

	vec.crossVectors( tangents[ 0 ], normal ).normalize();

	normals[ 0 ].crossVectors( tangents[ 0 ], vec );
	binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


	// compute the slowly-varying normal and binormal vectors for each segment on the curve

	for ( i = 1; i &lt;= segments; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}

	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed === true ) {

		theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
		theta /= segments;

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i &lt;= segments; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

	return {
		tangents: tangents,
		normals: normals,
		binormals: binormals
	};

}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">x-visual API</a></h2><h3>Classes</h3><ul><li><a href="AbsCluster.html">AbsCluster</a></li><li><a href="Affine.html">Affine</a></li><li><a href="AffineCombiner.html">AffineCombiner</a></li><li><a href="AssetKeepr.html">AssetKeepr</a></li><li><a href="Axisys.html">Axisys</a></li><li><a href="BaseComponent.html">BaseComponent</a></li><li><a href="CamCtrl.html">CamCtrl</a></li><li><a href="CanvTex.html">CanvTex</a></li><li><a href="ChannelFilter.html">ChannelFilter</a></li><li><a href="chart.html">chart</a></li><li><a href="chart.Axes.html">Axes</a></li><li><a href="chart.Bar.html">Bar</a></li><li><a href="chart.GridElem.html">GridElem</a></li><li><a href="chart.Pie.html">Pie</a></li><li><a href="chart.Sankey.html">Sankey</a></li><li><a href="CoordsGrid.html">CoordsGrid</a></li><li><a href="D3Pie.html">D3Pie</a></li><li><a href="ECS.html">ECS</a></li><li><a href="Entity.html">Entity</a></li><li><a href="FilmEffect.html">FilmEffect</a></li><li><a href="GpuPicker.html">GpuPicker</a></li><li><a href="GridVisuals.html">GridVisuals</a></li><li><a href="Htmltex.html">Htmltex</a></li><li><a href="Hud.html">Hud</a></li><li><a href="Input.html">Input</a></li><li><a href="Layers.html">Layers</a></li><li><a href="Mapctrl.html">Mapctrl</a></li><li><a href="mat4.html">mat4</a></li><li><a href="MorphingAnim.html">MorphingAnim</a></li><li><a href="OSM3.html">OSM3</a></li><li><a href="OsmUtils.html">OsmUtils</a></li><li><a href="PathEffect.html">PathEffect</a></li><li><a href="pickuuid.html">pickuuid</a></li><li><a href="RayPicker.html">RayPicker</a></li><li><a href="rayuuid.html">rayuuid</a></li><li><a href="Request.html">Request</a></li><li><a href="System.html">System</a></li><li><a href="Textag.html">Textag</a></li><li><a href="ThreeExt.html">ThreeExt</a></li><li><a href="ThreeExt.DirTubeBufferGeometry.html">DirTubeBufferGeometry</a></li><li><a href="ThreeExt.DirTubeGeometry.html">DirTubeGeometry</a></li><li><a href="Thrender.html">Thrender</a></li><li><a href="TilesKeeper.html">TilesKeeper</a></li><li><a href="Tween.html">Tween</a></li><li><a href="vec3.html">vec3</a></li><li><a href="Vec3_.html">Vec3</a></li><li><a href="global.html#x">x</a></li><li><a href="XComponent.html">XComponent</a></li><li><a href="XComponent.Canvas.html">Canvas</a></li><li><a href="XComponent.CmdFlag.html">CmdFlag</a></li><li><a href="XComponent.CmpTween.html">CmpTween</a></li><li><a href="XComponent.CmpTweens.html">CmpTweens</a></li><li><a href="XComponent.Dynatex.html">Dynatex</a></li><li><a href="XComponent.Filming.html">Filming</a></li><li><a href="XComponent.FlowingPath.html">FlowingPath</a></li><li><a href="XComponent.Glow.html">Glow</a></li><li><a href="XComponent.GlowingEdge.html">GlowingEdge</a></li><li><a href="XComponent.GpuPickable.html">GpuPickable</a></li><li><a href="XComponent.HudChild.html">HudChild</a></li><li><a href="XComponent.HudGroup.html">HudGroup</a></li><li><a href="XComponent.Input.html">Input</a></li><li><a href="XComponent.ModelSeqs.html">ModelSeqs</a></li><li><a href="XComponent.Obj3.html">Obj3</a></li><li><a href="XComponent.Occluder.html">Occluder</a></li><li><a href="XComponent.RayCastee.html">RayCastee</a></li><li><a href="XComponent.TweenScript.html">TweenScript</a></li><li><a href="XComponent.UserCmd.html">UserCmd</a></li><li><a href="XComponent.UserTween.html">UserTween</a></li><li><a href="XComponent.Visual.html">Visual</a></li><li><a href="XComponent.XCamera.html">XCamera</a></li><li><a href="XError.html">XError</a></li><li><a href="xglsl.html">xglsl</a></li><li><a href="xmath.html">xmath</a></li><li><a href="XSankey.html">XSankey</a></li><li><a href="XSys.html">XSys</a></li><li><a href="XTweener.html">XTweener</a></li><li><a href="XTweenException.html">XTweenException</a></li><li><a href="xutils.html">xutils</a></li><li><a href="XWorld.html">XWorld</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AffineTrans">AffineTrans</a></li><li><a href="global.html#AffineType">AffineType</a></li><li><a href="global.html#browserVer">browserVer</a></li><li><a href="global.html#getEffectPass">getEffectPass</a></li><li><a href="global.html#interpret">interpret</a></li><li><a href="global.html#KeyFlag">KeyFlag</a></li><li><a href="global.html#LayerChannel">LayerChannel</a></li><li><a href="global.html#onMouse">onMouse</a></li><li><a href="global.html#phongMorph2">phongMorph2</a></li><li><a href="global.html#R">R</a></li><li><a href="global.html#xcam">xcam</a></li><li><a href="global.html#XEasing">XEasing</a></li><li><a href="global.html#xecs">xecs</a></li><li><a href="global.html#xscene">xscene</a></li><li><a href="global.html#xview">xview</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Jun 18 2020 13:45:56 GMT+0800 (Hong Kong Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
